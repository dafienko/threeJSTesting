<!DOCTYPE html> 

<html>
    <head>
        <link rel="stylesheet" href="styles.css">
    </head>

    <script type="module">
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/build/three.module.js';
        
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas});
        
        const fov = 85;
        const aspect = canvas.width / canvas.height;  // the canvas default
        const near = 0.1;
        const far = 150;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        
        
        camera.position.z = 2;
        
        const scene = new THREE.Scene();
        
        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
        
        const material = new THREE.MeshPhongMaterial({color: 0x44aa88});
        const size = 10;
        const cubes = new THREE.InstancedMesh(geometry, material, size * size * size);
        
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(-1, 2, 4);
        
        
        scene.add(cubes);
        scene.add(light);
        
        class Star {
            constructor() {
                this.scale = .3 + Math.random() * .5
                this.theta = Math.random() * 2 * Math.PI;

                function getRadius(x) {
                    return .5 * Math.floor(Math.pow(1.5, 5 * x) - 1);
                }
                this.r = getRadius(Math.random());
            }

            getMatrix() {
                let m = THREE.Matrix4();
                m.multiply(new THREE.Matrix4().makeScale(s, s, s));
                m.multiply(new THREE.Matrix4().makeRotationY(time * .7));
                m.multiply( new THREE.Matrix4().setPosition((x - size / 2) * scale, (y - size / 2) * scale, (z - size / 2) * scale - 10));
            }
        }

        function render(time) {
            let w = window.innerWidth;
            let h = window.innerHeight;

            canvas.width = w;
            canvas.height = h;
            renderer.setSize(w, h);

            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        
            time *= 0.001;  // convert time to seconds
        
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        let m = new THREE.Matrix4();
                        let scale = 2
                        let s = .2;
                        m.setPosition((x - size / 2) * scale, (y - size / 2) * scale, (z - size / 2) * scale - 10);
                        m.multiply(new THREE.Matrix4().makeRotationY(time * .7));
                        m.multiply(new THREE.Matrix4().makeRotationX(time * .7));
                        m.multiply(new THREE.Matrix4().makeScale(s, s, s));

                        let index = x * size * size + y * size + z;
                        //console.log(index);
                        cubes.setMatrixAt(index, m);
                        cubes.instanceMatrix.needsUpdate = true;
                    }
                }
            }
        
            renderer.render(scene, camera);
        
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>

    <body>
        <div>
            <canvas id="c" width=700 height=600></canvas>
        </div>
    </body>
</html>